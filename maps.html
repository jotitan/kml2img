<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="lib/jquery-1.11.0.min.js"></script>
    <script type="text/javascript"
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCf0e7TC34X6EzkpsvtKyuqebjiosrzwak">
    </script>
</head>
<body>

 <script>
    var key = "AIzaSyCf0e7TC34X6EzkpsvtKyuqebjiosrzwak";
	var debug = false;
    var bounds = {minX:180,minY:180,maxX:-180,maxY:-180};
    var size = {width:1400,height:2000,window:256};
	var realSize = $.extend({},size);
    var markers = [];
	var styles = [];
	var paths = [];
	var zoom = 1;
	var docInfo;
	var canvas;
    var logoShift = 25;
    function loadKML(file){
        $.ajax({url:file,dataType:'xml',success:function(data){
            docInfo = $(data).find('Document')[0];
            loadStyles(docInfo);
			loadInfos(docInfo);
			showImage();
        }});
    }

	function loadStyles(docInfo){
		var stylesXml = $(docInfo).find('Style');
		for(var i = 0 ; i <stylesXml.length ; i++){
			var style = stylesXml[i];
			var id = "#" + style.getAttribute("id");
			var icon = extractValue($(style),'IconStyle > Icon > href');
			if(icon!=null){
				styles[id] = {icon:icon};
			}else{
				var lineStyle = $(style).find('LineStyle');
				if(lineStyle.length > 0){
					var ls = $(lineStyle[0]);
					styles[id] = {color:convertColor(extractValue(ls,'color')),width:extractValue(ls,'width')};
				}				
			}
		}
	}
	
	var colorReg = new RegExp(/([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i);
	/* Converti une couleur BGR en RGB */
	function convertColor(color){
		return color.replace(colorReg,'$4$3$2')
	}

    function round(value){
        return Math.round(parseFloat(value) * 100000) / 100000;
    }

     function loadInfos(data){
         var points = $(data).find('Placemark');
         for(var i = 0 ; i < points.length ; i++){
		     var styleId = extractValue($(points[i]),'styleUrl');
             var name = extractValue($(points[i]),'name');
             var point = extractValue($(points[i]),'Point > coordinates');
			 if(point != null){
				 var p = point.split(",");
				 var x = round(p[0]);
				 var y = round(p[1]);
				 updateBounds(x,y);
				 markers.push({x:x,y:y,style:styles[styleId],name:name});
			 }else{
				var line = extractValue($(points[i]),'LineString > coordinates');
				if(line != null){
					var coords = line.split(" ");	
					var pointsLine = coords.map(function(c){
                        if(c!=null && c.length >5){
                            var pointLine = {lng:round(c.split(",")[0]),lat:round(c.split(",")[1])};
                            updateBounds(pointLine.lng,pointLine.lat,c);
                            return pointLine;
                        }
					});
					paths.push({points:pointsLine,style:styles[styleId],name:name});
					
				}
			 }
         };		
		 bounds.minX = bounds.minX-(bounds.maxX - bounds.minX)*0.1;
     }
	 	 
	 function extractValue(data,path){
		var datas = data.find(path);
		if(datas.length > 0){
			var childNodes = datas[0].childNodes;
			var value = "";
			// Warning, limit to 4096 each nodeValue size
			for(var i = 0 ; i < childNodes.length ; i++){
				value+=childNodes[i].nodeValue;
			}
			return value;
		}
		return null;
	 }
	 
     function updateBounds(x,y,c){
         bounds.minX = Math.min(bounds.minX,x);
         bounds.minY = Math.min(bounds.minY,y);
         bounds.maxX = Math.max(bounds.maxX,x);
         bounds.maxY = Math.max(bounds.maxY,y);
     }

    function findBounds(lat,lng,zoom){
        var projection = map.getProjection();

        // Get the first point (bottom of tile)
        var downPoint = projection.fromLatLngToPoint(new google.maps.LatLng(lat,lng));
        // Get the size of a tile at this zoom
        var lengthLat = (256 - logoShift)/Math.pow(2,zoom);
        var lengthLng = 256/Math.pow(2,zoom);

        var upPoint = new google.maps.Point(downPoint.x + lengthLng,downPoint.y + lengthLat);
        var upBounds = projection.fromPointToLatLng(upPoint);
        var deltaLng = (upBounds.lng() - lng)/256*size.window;
        var deltaLat = (lat - upBounds.lat())/256*(size.window);

        return {lat:deltaLat,lng:deltaLng};

    }
	
	function findZoom(){
		
	}
	
	function getSizeWindowInKm(){
		/* largeur (longitude) fixe en angle / distance, mais pas en latitude (longueur non conservee) */
		/* Les angles sont conserves */
		var lat = GeoLoc.getDistanceLat(bounds.minY,bounds.maxY) / size.height;
		var lng = GeoLoc.getDistanceLng(bounds.minX,bounds.maxX,bounds.minY) / size.width;
		var max = Math.max(lat,lng);
		var angle = GeoLoc.getAngleLat(max*size.window);
		zoom = Math.round(Math.log(360/angle) / Math.log(2)) -1;
	}
	
	 // http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/
	 var GeoLoc = {
		degreInKm:111.195,
		rayon:6371,
				
		getAngleLat:function(distance){
			return distance/this.degreInKm;
		},
				
		getDistanceLat:function(latMin,latMax){
			var angleLat = latMax - latMin;
			return angleLat*this.degreInKm;
		},
		getDistanceLng:function(lngMin,lngMax,lat){
			var circle = this.getCircleToLatitude(lat);
			return ((lngMax - lngMin)/360) * circle;			
		},
		
		getCircleToLatitude:function(latitude){
			var adjustRayon = (Math.PI/2 - this.degreeToRad(latitude)) * this.rayon;
			return adjustRayon * 2 * Math.PI;
		},
		degreeToRad : function(alpha){
			return (alpha*Math.PI/180);
		}
	 }
	 
	function createCanvas(){
		$('body').append('<canvas id="canvas" height="' + realSize.height + '" width="' + realSize.width + '"></canvas>');
		canvas = document.getElementById("canvas").getContext("2d");
	}
	
	var nbTotal = 0;
	 
    function showImage(){
		getSizeWindowInKm();
		
		realSize.width = Math.ceil(size.width/size.window)*size.window;
		realSize.height = Math.ceil(size.height/size.window)*size.window;
		
		createCanvas();
		
		var tot = 0;
    	var currentPoint = {lat:bounds.maxY,lng:bounds.minX};
		size.maxJ = Math.ceil(size.height/size.window);
		size.maxI = Math.ceil(size.width/size.window) -1;
		for(var j = Math.ceil(size.height/size.window) ; j>=0 ;j--){
			currentPoint.lng = bounds.minX;
			var delta = findBounds(currentPoint.lat,currentPoint.lng,zoom);
			for(var i = 0 ; i < Math.ceil(size.width/size.window);i++){            				
				var bds = {minY:parseFloat(currentPoint.lat.toFixed(3)),minX:parseFloat(currentPoint.lng.toFixed(3)),
					maxY:parseFloat((currentPoint.lat+delta.lat).toFixed(3)),maxX:parseFloat((currentPoint.lng + delta.lng).toFixed(3))};
				currentPoint.lng+=delta.lng;				
				var url = buildPartial(bds,i,j);
				if(url!=null){
                    nbTotal++;
                    tot+=url.length;
					addImgToCanvas(i,j,url);
				}
            }
			currentPoint.lat-=delta.lat;
			$('body').append('<br/>');
        }
        console.log("moy : " + (tot/nbTotal));
    }

	var nbLoaded = 0;
	var images = [];
		
	function addImgToCanvas(i,j,url){
		if(debug){
			$('body').append('<img src="' + url + '" style="border:solid 1px black;width:' + size.window + 'px;style:' + size.window + 'px;margin-top:-5px"/>');					
		}else{
		var img = new Image();
			img.src = url;
			img.onload = function(){
				images[i+"-"+j] = img;
				nbLoaded++;
				if(nbLoaded == nbTotal){
					finalDraw();
				}
			};
		}

	}
	
	/* Draw the map */
	function finalDraw(){
		for(var j = size.maxJ ; j >=0  ; j--){
			for(var i = 0 ; i <= size.maxI ; i++){
				canvas.drawImage(images[i+"-"+j], i*size.window, realSize.height - j*(size.window - logoShift), size.window, size.window);
			}
		}	
	}
	
    function buildPartial(bds,i,j){
        var url = "http://maps.googleapis.com/maps/api/staticmap?size=" + size.window + "x" + size.window + "&maptype=roadmap&sensor=true&key=" + key;
        url+="&zoom=" + zoom + "&center=" + ((bds.minY +bds.maxY)/2)+ "," + ((bds.minX +bds.maxX)/2);
        url+=buildMarkers(bds);
		url+=buildLines(bds,i,j);
        return url;
    }

    function buildMarkers(bds){
		if(markers.length > 0){
			var url = "";
            // Element distant of 10 px
			var pas = ((bds.maxX - bds.minX)/size.window) * 10;
            var drawMarks = [];
			markers.forEach(function(m){
                if(m.y >= (bds.minY-pas) && m.y < (bds.maxY +pas) && m.x > (bds.minX -pas) && m.x < (bds.maxX + pas)){
					var present = drawMarks.some(function(mark){
                        var lb = {minX:mark.x-pas,maxX:parseFloat(mark.x+pas),minY:mark.y-pas,maxY:parseFloat(mark.y+pas)};
						return m.x >= lb.minX && m.x <=lb.maxX && m.y >= lb.minY && m.y <= lb.maxY;
					});
					if(!present){
       				drawMarks.push(m);
						url+="&markers=" + ((m.style == null || m.style.icon == null)?"color:red":"icon:" + m.style.icon);
						url+="|" + m.y + "," + m.x;
					}
                }
            });
            return url;
        }
        return "";
    }

	function buildLines(bds,i,j){
		var url = "";
		if(paths.length > 0){
			var pas = ((bds.maxX - bds.minX)/size.window) * 20;
			paths.forEach(function(path){
				var pointsToDraw = [];
				var lastPoint = null;
				var lastHiddenPoint;
				path.points.forEach(function(p){
					if(p == null){return;}
					// Verify if point is enough distant
					if(p!=null && p.lat >= (bds.minY-pas) && p.lat < (bds.maxY +pas) && p.lng > (bds.minX -pas) && p.lng < (bds.maxX + pas)){
						//console.log("IN",p);
						if(lastPoint == null || 
							( Math.sqrt(Math.pow(lastPoint.lng - p.lng,2) + Math.pow(lastPoint.lat - p.lat,2)) > pas)){								
								if(lastHiddenPoint!=null){
									pointsToDraw.push(lastHiddenPoint);
								}
								pointsToDraw.push(p);
								lastPoint = p;
						}
						lastHiddenPoint = null;
					}else{	
						//console.log("OUT",p);
						if(lastHiddenPoint == null && lastPoint == null){
							lastHiddenPoint = p;
						}else{
							var tempPoint = lastHiddenPoint || lastPoint;
							if(p!=null && droiteIsInPlan({x:tempPoint.lng,y:tempPoint.lat},{x:p.lng,y:p.lat},bds)){								
								// Si traverse image, on affiche les deux points, sinon, sortie de trait, on affiche pas le point
								// (deja ecrit)
								if(lastHiddenPoint!=null){
									pointsToDraw.push(tempPoint);
								}
								pointsToDraw.push(p);
								lastHiddenPoint = p;
								lastPoint = null;
							}else{
								lastHiddenPoint = p;
							}
						}
					}
				});
				if(pointsToDraw.length > 0){				
					var style = (path.style!=null)?("color:0x" + path.style.color + "ff|weight:" + path.style.width):"color:black|weight:2";
					url+="&path=" + style;
					pointsToDraw.forEach(function(p){
						url+="|" + p.lat + "," + p.lng;
					});
				}
			});
		}
		return url;
	}

	function droiteIsInPlan(pA,pB,bds){
		if((pA.x > bds.minX && pB.x < bds.minX) || (pA.x < bds.minX && pB.x > bds.minX) ||
		(pA.y > bds.minY && pB.y < bds.minY) || (pA.y < bds.minY && pB.y > bds.minY)){
		
		}else{
			return false;
		}
		
		if(pB.x == pA.x){
			//Vertical, x fixe
			// Il faut que x soit compris entre xMin et xMax et bds compris entre minY et maxY
			return bds.minX <= pA.x && bds.maxX >= pA.x && (
				(bds.minY >= pA.y && bds.maxY <= pB.y) || 				
				(bds.minY >= pB.y && bds.maxY <= pA.y));
		}else{
			var a = (pB.y - pA.y) / (pB.x - pA.x);
			var b = pB.y - pB.x * a;
			//  Horizontal
			if(a == 0){
			
			}else{
				// On cherche pour les 4 points si intersection dans la zone
				// Pour minY, doit etre compris entre entre minX et maxX
				var x = (bds.minY - b)/a;
				if(x >= bds.minX && x <= bds.maxX){return true;}
				x = (bds.maxY - b)/a;
				if(x >= bds.minX && x <= bds.maxX){return true;}
				
				var y = a * bds.minX + b;
				if(y >= bds.minY && y <= bds.maxY){return true;}
				y = a * bds.maxX + b;
				if(y >= bds.minY && y <= bds.maxY){return true;}
			}
		}
		
		return false;
	}
	
	var map;
	$(function(){
		map = new google.maps.Map($('#map').get(0),{zoom:8,center:new google.maps.LatLng(0,0)});
		google.maps.event.addListener(map, 'projection_changed', function(){
			//loadKML("resources/norvege.kml");
			loadKML("resources/export.kml");
		});
	});

 </script>
 
<div id="map" style="width:100px:height:100px;visibility:none"></div>

</body>
</html>