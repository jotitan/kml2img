<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="lib/jquery-1.11.0.min.js"></script>
    <script type="text/javascript"
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCf0e7TC34X6EzkpsvtKyuqebjiosrzwak&libraries=geometry">
    </script>
</head>
<body>

 <script>
	var debug = false;
    var key = "AIzaSyCf0e7TC34X6EzkpsvtKyuqebjiosrzwak";
	var ROOT_URL = "http://maps.googleapis.com/maps/api/staticmap?key=" + key;
    var bounds = {minX:180,minY:180,maxX:-180,maxY:-180};
    var size = {width:1400,height:2000,window:256};
	var realSize = $.extend({},size);
    var logoShift = 25;	// To avoid google logo display
	var fixBounds = {minX:12.5,maxX:15.5,minY:66.7,maxY:69.3};
	
    function loadKML(file){
        $.ajax({url:file,dataType:'xml',success:function(data){
            loadImage($(data).find('Document')[0]);
        }});
    }
	
	function loadImage(docInfo){
		var mapInfo = {styles:[],markers:[],paths:[],zoom:1};

		mapInfo.styles = loadStyles(docInfo);
		loadInfos(docInfo,mapInfo.markers,mapInfo.paths,mapInfo.styles);
		if(fixBounds!=null){
			bounds = fixBounds;
		}
		mapInfo.zoom = findZoom();
		showImage(mapInfo);
	}

	function loadStyles(docInfo){
		var stylesXml = $(docInfo).find('Style');
		var tab = [];
		for(var i = 0 ; i <stylesXml.length ; i++){
			var style = stylesXml[i];
			var id = "#" + style.getAttribute("id");
			var icon = extractValue($(style),'IconStyle > Icon > href');
			if(icon!=null){
				tab[id] = {icon:icon};
			}else{
				var lineStyle = $(style).find('LineStyle');
				if(lineStyle.length > 0){
					var ls = $(lineStyle[0]);
					tab[id] = {color:Utils.convertColor(extractValue(ls,'color')),width:extractValue(ls,'width')};
				}				
			}
		}
		return tab;
	}
	
	var Utils = {
		colorReg:new RegExp(/([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i),
		pas:100000,
		convertColor:function(color){
			return color.replace(this.colorReg,'$4$3$2');
		},
		round:function(value){
			return Math.round(parseFloat(value) * this.pas) / this.pas;
		}
	}

     function loadInfos(data,markers,paths,styles){
         var points = $(data).find('Placemark');
         for(var i = 0 ; i < points.length ; i++){
		     var styleId = extractValue($(points[i]),'styleUrl');
             var name = extractValue($(points[i]),'name');
             var point = extractValue($(points[i]),'Point > coordinates');
			 if(point != null){
				 var p = point.split(",");
				 var x = Utils.round(p[0]);
				 var y = Utils.round(p[1]);
				 updateBounds(x,y);
				 markers.push({x:x,y:y,style:styles[styleId],name:name});
			 }else{
				var line = extractValue($(points[i]),'LineString > coordinates');
				if(line != null){
					var coords = line.split(" ");	
					var pointsLine = coords.map(function(c){
                        if(c!=null && c.length >5){
							var p = c.split(",");
                            var pointLine = {lng:Utils.round(p[0]),lat:Utils.round(p[1])};
                            updateBounds(pointLine.lng,pointLine.lat,c);
                            return pointLine;
                        }
					});
					paths.push({points:pointsLine,style:styles[styleId],name:name});					
				}
			 }
         };		
		 bounds.minX = bounds.minX-(bounds.maxX - bounds.minX)*0.1;
     }
	 	 
	 function extractValue(data,path){
		var datas = data.find(path);
		if(datas.length > 0){
			var childNodes = datas[0].childNodes;
			var value = "";
			// Warning, limit to 4096 each nodeValue size
			for(var i = 0 ; i < childNodes.length ; i++){
				value+=childNodes[i].nodeValue;
			}
			return value;
		}
		return null;
	 }
	 
     function updateBounds(x,y,c){
         bounds.minX = Math.min(bounds.minX,x);
         bounds.minY = Math.min(bounds.minY,y);
         bounds.maxX = Math.max(bounds.maxX,x);
         bounds.maxY = Math.max(bounds.maxY,y);
     }

    function findBounds(lat,lng,zoom){
        var projection = map.getProjection();

        // Get the first point (bottom of tile)
        var downPoint = projection.fromLatLngToPoint(new google.maps.LatLng(lat,lng));
        // Get the size of a tile at this zoom
        var lengthLat = (256 - logoShift)/Math.pow(2,zoom);
        var lengthLng = 256/Math.pow(2,zoom);

        var upPoint = new google.maps.Point(downPoint.x + lengthLng,downPoint.y + lengthLat);
        var upBounds = projection.fromPointToLatLng(upPoint);
        var deltaLng = (upBounds.lng() - lng)/256*size.window;
        var deltaLat = (lat - upBounds.lat())/256*(size.window);

        return {lat:deltaLat,lng:deltaLng};
    }
	
	/* Find correct zoom */
	function findZoom(){
		var pMin = map.getProjection().fromLatLngToPoint(new google.maps.LatLng(bounds.minX,bounds.minY));
		var pMax = map.getProjection().fromLatLngToPoint(new google.maps.LatLng(bounds.maxX,bounds.maxY));
		
		var zoomX = Math.log(size.width / Math.abs(pMax.x - pMin.x)) / Math.log(2)-1;
		var zoomY = Math.log(size.height / Math.abs(pMax.y - pMin.y)) / Math.log(2)-1;
		
		return Math.round(Math.min(zoomX,zoomY));
	}
	
	 // http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/	
	 
	function createCanvas(width,height){
		$('body').append('<canvas id="canvas" height="' + height + '" width="' + width + '"></canvas>');
		return document.getElementById("canvas").getContext("2d");
	}
	
	var nbTotal = 0;
	 
    function showImage(mapInfo){		
		size.maxJ = Math.ceil(size.height/size.window);
		size.maxI = Math.ceil(size.width/size.window);
		
		realSize.width = size.maxI*size.window;
		realSize.height = size.maxJ*(size.window - logoShift);
				
		var canvas = createCanvas(realSize.width,realSize.height);
		
		var tot = 0;var max = 0;
    	var currentPoint = {lat:bounds.maxY,lng:bounds.minX};
		
		for(var j = size.maxJ ; j>=0 ;j--){
			currentPoint.lng = bounds.minX;
			var delta = findBounds(currentPoint.lat,currentPoint.lng,mapInfo.zoom);
			for(var i = 0 ; i <= size.maxI;i++){            				
				var bds = {minY:currentPoint.lat,minX:currentPoint.lng,
					maxY:(currentPoint.lat+delta.lat),maxX:(currentPoint.lng + delta.lng)};				
				currentPoint.lng+=delta.lng;				
				var url = buildPartial(bds,i,j,mapInfo);
				if(url!=null){
                    nbTotal++;
                    tot+=url.length;
					max = Math.max(max,url.length);
					addImgToCanvas(i,j,url,canvas);
				}
            }
			// Shift actuel latitude with compute delta (local to a tile)
			currentPoint.lat-=delta.lat;
			if(debug){
				$('body').append('<br/>');
			}
        }
        console.log("moy : " + (tot/nbTotal) + ", max : " + max + " , zoom " + mapInfo.zoom);
    }

	var nbLoaded = 0;
	var images = [];
		
	function addImgToCanvas(i,j,url,canvas){
		if(debug){
			$('body').append('<img src="' + url + '" style="border:solid 1px black;width:' + size.window + 'px;style:' + size.window + 'px;margin-top:-5px"/>');					
		}else{
		var img = new Image();
			img.src = url;
			img.onload = function(){
				images[i+"-"+j] = img;
				if(++nbLoaded == nbTotal){
					finalDraw(canvas);
				}
			};
		}
	}
	
	/* Draw the map */
	function finalDraw(canvas){
		for(var j = size.maxJ ; j >=0  ; j--){
			for(var i = 0 ; i <= size.maxI ; i++){
				canvas.drawImage(images[i+"-"+j], i*size.window, realSize.height - j*(size.window - logoShift), size.window, size.window);
			}
		}	
	}
	
    function buildPartial(bds,i,j,mapInfo){
        var url = ROOT_URL + "&size=" + size.window + "x" + size.window + "&maptype=roadmap&sensor=true";
        url+="&zoom=" + mapInfo.zoom + "&center=" + ((bds.minY +bds.maxY)/2)+ "," + ((bds.minX +bds.maxX)/2);
        url+=buildMarkers(bds,mapInfo.markers);
		url+=buildLines(bds,mapInfo.paths,i,j);
        return url;
    }

    function buildMarkers(bds,markers){
		if(markers.length > 0){
			var url = "";
            // Element distant of 10 px
			var pas = ((bds.maxX - bds.minX)/size.window) * 10;
            var drawMarks = [];
			markers.forEach(function(m){
                if(m.y >= (bds.minY-pas) && m.y < (bds.maxY +pas) && m.x > (bds.minX -pas) && m.x < (bds.maxX + pas)){
					var present = drawMarks.some(function(mark){
                        var lb = {minX:mark.x-pas,maxX:parseFloat(mark.x+pas),minY:mark.y-pas,maxY:parseFloat(mark.y+pas)};
						return m.x >= lb.minX && m.x <=lb.maxX && m.y >= lb.minY && m.y <= lb.maxY;
					});
					if(!present){
       				drawMarks.push(m);
						url+="&markers=" + ((m.style == null || m.style.icon == null)?"color:red":"icon:" + m.style.icon);
						url+="|" + m.y + "," + m.x;
					}
                }
            });
            return url;
        }
        return "";
    }

	function buildLines(bds,paths,i,j){
		var url = "";
		if(paths.length > 0){
			var pas = ((bds.maxX - bds.minX)/size.window) * 20;
			paths.forEach(function(path){
				var pointsToDraw = [];
				var lastPoint = null;
				var lastHiddenPoint;
				path.points.forEach(function(p){
					if(p == null){return;}
					// Verify if point is enough distant
					if(p!=null && p.lat >= (bds.minY-pas) && p.lat < (bds.maxY +pas) && p.lng > (bds.minX -pas) && p.lng < (bds.maxX + pas)){
						if(lastPoint == null || 
							( Math.sqrt(Math.pow(lastPoint.lng - p.lng,2) + Math.pow(lastPoint.lat - p.lat,2)) > pas)){								
								if(lastHiddenPoint!=null){
									pointsToDraw.push(lastHiddenPoint);
								}
								pointsToDraw.push(p);
								lastPoint = p;
						}
						lastHiddenPoint = null;
					}else{	
						if(lastHiddenPoint == null && lastPoint == null){
							lastHiddenPoint = p;
						}else{
							var tempPoint = lastHiddenPoint || lastPoint;
							if(p!=null && lineIsInPlan({x:tempPoint.lng,y:tempPoint.lat},{x:p.lng,y:p.lat},bds)){								
								// Si traverse image, on affiche les deux points, sinon, sortie de trait, on affiche pas le point
								// (deja ecrit)
								if(lastHiddenPoint!=null){
									pointsToDraw.push(tempPoint);
								}
								pointsToDraw.push(p);
								lastHiddenPoint = p;
								lastPoint = null;
							}else{
								lastHiddenPoint = p;
							}
						}
					}
				});
				if(pointsToDraw.length > 0){				
					var style = (path.style!=null)?("color:0x" + path.style.color + "ff|weight:" + path.style.width):"color:black|weight:2";
					url+="&path=" + style;
					// Encode path to have shorter string
					var points = pointsToDraw.map(function(p){return new google.maps.LatLng(p.lat,p.lng);});
					var encode = google.maps.geometry.encoding.encodePath(points);
					url+="|enc:" + encode;					
				}
			});
		}
		return url;
	}

	function lineIsInPlan(pA,pB,bds){
		if((pA.x > bds.minX && pB.x < bds.minX) || (pA.x < bds.minX && pB.x > bds.minX) ||
		(pA.y > bds.minY && pB.y < bds.minY) || (pA.y < bds.minY && pB.y > bds.minY)){
		
		}else{
			return false;
		}
		
		if(pB.x == pA.x){
			//Vertical, x fixe
			// Il faut que x soit compris entre xMin et xMax et bds compris entre minY et maxY
			return bds.minX <= pA.x && bds.maxX >= pA.x && (
				(bds.minY >= pA.y && bds.maxY <= pB.y) || 				
				(bds.minY >= pB.y && bds.maxY <= pA.y));
		}else{
			var a = (pB.y - pA.y) / (pB.x - pA.x);
			var b = pB.y - pB.x * a;
			//  Horizontal
			if(a == 0){
			
			}else{
				// On cherche pour les 4 points si intersection dans la zone
				// Pour minY, doit etre compris entre entre minX et maxX
				var x = (bds.minY - b)/a;
				if(x >= bds.minX && x <= bds.maxX){return true;}
				x = (bds.maxY - b)/a;
				if(x >= bds.minX && x <= bds.maxX){return true;}
				
				var y = a * bds.minX + b;
				if(y >= bds.minY && y <= bds.maxY){return true;}
				y = a * bds.maxX + b;
				if(y >= bds.minY && y <= bds.maxY){return true;}
			}
		}
		
		return false;
	}
	
	var map;
	$(function(){
		map = new google.maps.Map($('#map').get(0),{zoom:8,center:new google.maps.LatLng(0,0)});
		google.maps.event.addListener(map, 'projection_changed', function(){
			loadKML("resources/norvege.kml");
			//loadKML("resources/export.kml");
		});
	});

 </script>
 
<div id="map" style="width:100px:height:100px;visibility:none"></div>

</body>
</html>